# 领域驱动设计

领域驱动设计（Domain-Driven Design，简称 DDD）是由 Eric Evans 在其著作 Domain-Driven Design: Tackling Complexity in the
Heart of Software 中提出的一种软件设计思想。

## 一句话理解 DDD

👉 **让程序围绕“业务本身”来设计，而不是围绕数据库或技术框架来设计。**

## 先举个生活例子 🌰

假设你要开发一个「电商系统」。

很多初学者会怎么做？

* 先建数据库表（user 表、order 表、product 表）
* 然后写 CRUD
* Controller → Service → Repository
* 业务逻辑到处写

结果是什么？

* 代码越来越乱
* 规则分散
* 修改一个功能影响很多地方
* 后期维护极其痛苦

这就是“以技术为中心”开发。

## DDD 的思路完全不一样

DDD 会问你：

> 这个系统真正的核心业务是什么？

在电商系统里，核心是：

* 订单是怎么生成的？
* 订单什么时候可以取消？
* 库存什么时候扣减？
* 优惠券什么时候可以用？

这些才是“领域”。

DDD 关注的是：

> 业务规则，而不是数据库结构。

## DDD 的核心思想（通俗版）

我给你拆成 5 个关键点 👇

### 1️⃣ 领域（Domain）

领域就是：

> 你正在解决的业务问题的范围

比如：

* 电商系统
* 银行系统
* 医疗系统
* 外卖系统

### 2️⃣ 统一语言（Ubiquitous Language）

开发和产品必须说同一种话。

比如：

❌ 不要说：
“我查一下 order_status = 3”

✅ 要说：
“订单已发货”

代码里也应该写：

```java
order.ship();
```

而不是：

```java
order.setStatus(3);
```

👉 代码要像在描述业务。

### 3️⃣ 实体（Entity）

有唯一身份的对象。

比如：

* 订单（Order）
* 用户（User）

订单即使金额变了，它还是同一个订单。

### 4️⃣ 值对象（Value Object）

没有唯一身份，只关心“值”。

比如：

* 地址（Address）
* 金额（Money）

100 元就是 100 元，没有 ID。

### 5️⃣ 聚合（Aggregate）

这是 DDD 最重要的概念之一。

聚合可以理解为：

> 一组强关联的对象组成的业务整体

比如：

订单（Order）包含：

* 订单项（OrderItem）
* 收货地址（Address）

你不能随便修改 OrderItem，
必须通过 Order 来改。

👉 Order 是聚合根。

## 用一句更直白的话解释 DDD

传统开发：

> 数据库驱动开发

DDD：

> 业务规则驱动开发

## 为什么 DDD 适合复杂系统？

如果系统很简单，比如：

* 后台管理系统
* 简单 CRUD 系统

其实不一定要 DDD。

但如果系统：

* 业务规则复杂
* 状态流转很多
* 规则经常变
* 多团队协作

DDD 会非常清晰。

## DDD 和三层架构的区别

传统三层：

```
Controller
   ↓
Service
   ↓
Repository
```

DDD 分层：

```
接口层（Interface）
应用层（Application）
领域层（Domain）⭐核心
基础设施层（Infrastructure）
```

👉 领域层才是核心。

## DDD 的目标

1. 让代码表达业务
2. 让业务规则集中
3. 降低复杂度
4. 提高可维护性
5. 适合长期演进的大系统

## 总结

DDD 就是：

> 把“业务逻辑”当成软件的中心，而不是数据库或框架。

